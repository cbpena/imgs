
#define VERSION "0.12.0"


#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <cstring>
#include <vector>



// ========================================
const int BPP					= 3;
const int FILEHEADER_SIZE		= 14;
const int INFOHEADER_SIZE		= 40;




// ========================================
#pragma pack(push, 1)
typedef struct {
    uint16_t bfType;				// Magic identifier
    uint32_t bfSize;				// File size in bytes
    uint16_t bfReserved1;
    uint16_t bfReserved2;
    uint32_t bfOffBits;				// Offset to image data, bytes
} BITMAPFILEHEADER, *LPBITMAPFILEHEADER;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct {
    uint32_t biSize;				/* Header size in bytes      */
    int32_t biWidth;				/* Width of image            */
	int32_t biHeight;				/* Height of image           */
    uint16_t biPlanes;				/* Number of colour planes   */
    uint16_t biBitCount;			/* Bits per pixel            */
    uint32_t biCompression;			/* Compression type          */
    uint32_t biSizeImage;			/* Image size in bytes       */
    int32_t biXPelsPerMeter;		/* Pixels per meter          */
	int32_t biYPelsPerMeter;		/* Pixels per meter          */
    uint32_t biClrUsed;				/* Number of colours         */
    uint32_t biClrImportant;		/* Important colours         */
} BITMAPINFOHEADER, *LPBITMAPINFOHEADER;
#pragma pack(pop)




// ========================================
class Bitmap
{
	private:
		bool valid;
	
		LPBITMAPFILEHEADER fh;
		LPBITMAPINFOHEADER ih;
		uint8_t* image;
		
		int32_t width_in_bytes;
		int32_t size_in_bytes;
		int32_t pad_size;
		int32_t stride;
		
	private:
		void init()
		{
			width_in_bytes = ih->biWidth * BPP;
			size_in_bytes = ih->biHeight * width_in_bytes;
			pad_size = (4 - (width_in_bytes) % 4) % 4;
			stride = width_in_bytes + pad_size;
		}
		
		int32_t calculate_stride(int32_t width)
		{
			return (width*BPP) + ((4 - (width*BPP) % 4) % 4);
		}
		
		void cleanup()
		{
			delete fh;
			delete ih;
			delete image;
			
			fh = 0;
			ih = 0;
			image = 0;
		}

	public:
		// ========================================
		// constructors
		Bitmap(std::string filename)
		{
			load(filename);
		}
		
		Bitmap(int32_t height, int32_t width)
		{
			fh = create_fileheader(height, calculate_stride(width));
			ih = create_infoheader(height, width);
			
			init();
			
			if (size_in_bytes > 0)
			{
				image = new uint8_t[size_in_bytes];
				
				// debug fill
			    //for (int32_t y = 0; y < ih->biHeight; y++)
				//{
			    //    for (int32_t x = 0; x < ih->biWidth; x++)
				//	{
				//		r(x,y, (uint8_t)( y * 255 / ih->biHeight ));
				//		g(x,y, (uint8_t)( x * 255 / ih->biWidth ));
				//		b(x,y, (uint8_t)((y+x) * 255 / (ih->biHeight+ih->biWidth)));
				//	}
			    //}
			    // end debug fill
				
			}
			else
				image = NULL;
				
			valid = (image != NULL);
		}
		
		// ========================================
		// destructor
		~Bitmap()
		{
			cleanup();
		}
		
		
		// ========================================
		bool load(std::string filename)
		{
			cleanup();
			
			FILE* f = fopen(filename.c_str(), "rb");
			
				fh = new BITMAPFILEHEADER();
				fread(fh, 1, FILEHEADER_SIZE, f);
				
				ih = new BITMAPINFOHEADER();
				fread(ih, 1, INFOHEADER_SIZE, f);

				init();
				
				if (size_in_bytes > 0)
				{
					image = new uint8_t[size_in_bytes];
					fread(image, 1, size_in_bytes, f);
				}
				else
					image = NULL;
					
				valid = (image != NULL);
				
			fclose(f);
		}
		
		
		bool save(std::string filename)
		{
			uint8_t pad[3] = {0, 0, 0};
			
			if (valid)
			{
				FILE* f = fopen(filename.c_str(), "wb");
				
					// write header data
					fwrite(fh, 1, FILEHEADER_SIZE, f);
					fwrite(ih, 1, INFOHEADER_SIZE, f);
			
					// write pixel data
					for (int32_t i = 0; i < ih->biHeight; i++)
					{
						fwrite(image + (i*width_in_bytes), BPP, ih->biWidth, f);
						fwrite(pad, 1, pad_size, f);
					}
					
				fclose(f);
				return true;
			}
			else
				return false;
		}
		
		
	private:
		// ========================================
		uint8_t r(int32_t x, int32_t y)
		{
			return image[ (width_in_bytes * y) + (x * BPP) + 0 ];
		}
		
		uint8_t g(int32_t x, int32_t y)
		{
			return image[ (width_in_bytes * y) + (x * BPP) + 1 ];
		}
		
		uint8_t b(int32_t x, int32_t y)
		{
			return image[ (width_in_bytes * y) + (x * BPP) + 2 ];
		}
		
		
		void r(int32_t x, int32_t y, uint8_t v)
		{
			image[ (width_in_bytes * y) + (x * BPP) + 0 ] = v;
		}
		
		void g(int32_t x, int32_t y, uint8_t v)
		{
			image[ (width_in_bytes * y) + (x * BPP) + 1 ] = v;
		}
		
		void b(int32_t x, int32_t y, uint8_t v)
		{
			image[ (width_in_bytes * y) + (x * BPP) + 2 ] = v;
		}
		
		
	public:
		int32_t height()	{ return ih->biHeight; }
		int32_t width()		{ return ih->biWidth; }
		
		uint32_t pixel(int32_t x, int32_t y)
		{
			if (valid && (x < ih->biWidth) && (y < ih->biHeight))
			{
				int32_t py = (ih->biHeight - y) - 1;
				return (r(x,py) << 16) | (g(x,py) << 8) | b(x,py);
			}
			else
				return 0;
		}	
		
		uint32_t pixelr(int32_t x, int32_t y)
		{
			if (valid && (x < ih->biWidth) && (y < ih->biHeight))
			{
				int32_t py = (ih->biHeight - y) - 1;
				return (b(x,py) << 16) | (g(x,py) << 8) | r(x,py);
			}
			else
				return 0;
		}
		
		void pixel(int32_t x, int32_t y, uint32_t v)
		{
			if (valid && (x < ih->biWidth) && (y < ih->biHeight))
			{
				int32_t py = (ih->biHeight - y) - 1;
				r( x, py, ((v >> 16) & 0xFF) );
				g( x, py, ((v >>  8) & 0xFF) );
				b( x, py, ( v        & 0xFF) );
			}
		}
		
		void pixelr(int32_t x, int32_t y, uint32_t v)
		{
			if (valid && (x < ih->biWidth) && (y < ih->biHeight))
			{
				int32_t py = (ih->biHeight - y) - 1;
				b( x, py, ((v >> 16) & 0xFF) );
				g( x, py, ((v >>  8) & 0xFF) );
				r( x, py, ( v        & 0xFF) );
			}
		}
		
		void fill(uint32_t v)
		{
			for (int32_t y = 0; y < ih->biHeight; y++)
			{
				for (int32_t x = 0; x < ih->biWidth; x++)
				{
					pixel(x,y,v);	
				}
			}
		}
		
		
		// ========================================
		// create info header
		static LPBITMAPINFOHEADER create_infoheader(int32_t h, int32_t w)
		{
			LPBITMAPINFOHEADER ih = new BITMAPINFOHEADER();
			memset(ih, 0, sizeof(BITMAPINFOHEADER));
			
				ih->biSize		= INFOHEADER_SIZE;
				ih->biWidth		= w;
				ih->biHeight	= h;
				ih->biPlanes	= 1;
				ih->biBitCount	= BPP * 8;
				
			return ih;
		}
		
		// ========================================
		// create file header
		static LPBITMAPFILEHEADER create_fileheader(int32_t h, int32_t stride)
		{
			int32_t filesize = FILEHEADER_SIZE + INFOHEADER_SIZE + (stride * h);
			
			LPBITMAPFILEHEADER fh = new BITMAPFILEHEADER();
			memset(fh, 0, sizeof(BITMAPFILEHEADER));
			
				fh->bfType		= 0x4D42;		// BM
				fh->bfSize		= filesize;
				fh->bfReserved1	= 0;
				fh->bfReserved2	= 0;
				fh->bfOffBits	= FILEHEADER_SIZE + INFOHEADER_SIZE;
			
			return fh;
		}

};



// ========================================
class ImagePosition
{
	public:
		std::string filename;
		int32_t src_x;
		int32_t src_y;
		int32_t src_w;
		int32_t src_h;
		int32_t dst_x;
		int32_t dst_y;
};




















// ################################################################################

uint32_t border_color = 0x00FF0000;



const int FONT_BASE = 32;
const int FONT_ROWS = 13;
const int FONT_COLS = 8;
const int FONT_SPACING = 2;

unsigned char font[95][13] = {
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},// 32:	space
{0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},// 33:	!
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36},
{0x00, 0x00, 0x00, 0x66, 0x66, 0xff, 0x66, 0x66, 0xff, 0x66, 0x66, 0x00, 0x00},
{0x00, 0x00, 0x18, 0x7e, 0xff, 0x1b, 0x1f, 0x7e, 0xf8, 0xd8, 0xff, 0x7e, 0x18},
{0x00, 0x00, 0x0e, 0x1b, 0xdb, 0x6e, 0x30, 0x18, 0x0c, 0x76, 0xdb, 0xd8, 0x70},
{0x00, 0x00, 0x7f, 0xc6, 0xcf, 0xd8, 0x70, 0x70, 0xd8, 0xcc, 0xcc, 0x6c, 0x38},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1c, 0x0c, 0x0e},
{0x00, 0x00, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c},
{0x00, 0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30},
{0x00, 0x00, 0x00, 0x00, 0x99, 0x5a, 0x3c, 0xff, 0x3c, 0x5a, 0x99, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18, 0x00, 0x00},
{0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x60, 0x60, 0x30, 0x30, 0x18, 0x18, 0x0c, 0x0c, 0x06, 0x06, 0x03, 0x03},
{0x00, 0x00, 0x3c, 0x66, 0xc3, 0xe3, 0xf3, 0xdb, 0xcf, 0xc7, 0xc3, 0x66, 0x3c},// 48:	0
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x38, 0x18},
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0xe7, 0x7e},
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0x07, 0x03, 0x03, 0xe7, 0x7e},
{0x00, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xff, 0xcc, 0x6c, 0x3c, 0x1c, 0x0c},
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xff},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
{0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x03, 0x03, 0xff},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e},
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x03, 0x7f, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e},
{0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x1c, 0x1c, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06},
{0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60},
{0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x18, 0x0c, 0x06, 0x03, 0xc3, 0xc3, 0x7e},
{0x00, 0x00, 0x3f, 0x60, 0xcf, 0xdb, 0xd3, 0xdd, 0xc3, 0x7e, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x18},
{0x00, 0x00, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
{0x00, 0x00, 0x7e, 0xe7, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
{0x00, 0x00, 0xfc, 0xce, 0xc7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc7, 0xce, 0xfc},
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xc0, 0xff},
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xff},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xcf, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e},
{0x00, 0x00, 0x7c, 0xee, 0xc6, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06},
{0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xe0, 0xf0, 0xd8, 0xcc, 0xc6, 0xc3},
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0},
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xdb, 0xff, 0xff, 0xe7, 0xc3},
{0x00, 0x00, 0xc7, 0xc7, 0xcf, 0xcf, 0xdf, 0xdb, 0xfb, 0xf3, 0xf3, 0xe3, 0xe3},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xe7, 0x7e},
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
{0x00, 0x00, 0x3f, 0x6e, 0xdf, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x66, 0x3c},
{0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0xe0, 0xc0, 0xc0, 0xe7, 0x7e},
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
{0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
{0x00, 0x00, 0xc3, 0xe7, 0xff, 0xff, 0xdb, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
{0x00, 0x00, 0xc3, 0x66, 0x66, 0x3c, 0x3c, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3},
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3},
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x7e, 0x0c, 0x06, 0x03, 0x03, 0xff},
{0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c},
{0x00, 0x03, 0x03, 0x06, 0x06, 0x0c, 0x0c, 0x18, 0x18, 0x30, 0x30, 0x60, 0x60},
{0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18},
{0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x38, 0x30, 0x70},
{0x00, 0x00, 0x7f, 0xc3, 0xc3, 0x7f, 0x03, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0},
{0x00, 0x00, 0x7e, 0xc3, 0xc0, 0xc0, 0xc0, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x03, 0x03, 0x03, 0x03, 0x03},
{0x00, 0x00, 0x7f, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x33, 0x1e},
{0x7e, 0xc3, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0},
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x00},
{0x38, 0x6c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x00, 0x00, 0x0c, 0x00},
{0x00, 0x00, 0xc6, 0xcc, 0xf8, 0xf0, 0xd8, 0xcc, 0xc6, 0xc0, 0xc0, 0xc0, 0xc0},
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78},
{0x00, 0x00, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xfe, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xfc, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00},
{0xc0, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0x00, 0x00, 0x00, 0x00},
{0x03, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe0, 0xfe, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xfe, 0x03, 0x03, 0x7e, 0xc0, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x1c, 0x36, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x00},
{0x00, 0x00, 0x7e, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc3, 0xe7, 0xff, 0xdb, 0xc3, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00},
{0xc0, 0x60, 0x60, 0x30, 0x18, 0x3c, 0x66, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xff, 0x60, 0x30, 0x18, 0x0c, 0x06, 0xff, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x0f, 0x18, 0x18, 0x18, 0x38, 0xf0, 0x38, 0x18, 0x18, 0x18, 0x0f},
{0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},
{0x00, 0x00, 0xf0, 0x18, 0x18, 0x18, 0x1c, 0x0f, 0x1c, 0x18, 0x18, 0x18, 0xf0},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x8f, 0xf1, 0x60, 0x00, 0x00, 0x00}  // :126
};

// ========================================
uint32_t print_hex(Bitmap &bmp, uint32_t x, uint32_t y, uint32_t v)
{
	char hex[8];
	uint32_t xbase = x;
	
	int len = sprintf(hex, "%X", v);

	if (len > -1)
	{
		for (size_t i = 0; i < len; i++)
		{
			for (size_t r = 0; r < FONT_ROWS; r++)
			{
				uint32_t row = font[hex[i]-FONT_BASE][FONT_ROWS - r - 1];
				for (size_t c = 0; c < FONT_COLS; c++)
				{
					if (row & 0x80)
						bmp.pixelr(xbase+c, y+r, border_color);
					row <<= 1;
				}
			}
			xbase += (FONT_COLS + FONT_SPACING);
		}
	}

	return xbase;
}

// ========================================
uint32_t print_string(Bitmap &bmp, uint32_t x, uint32_t y, std::string str)
{
	uint32_t xbase = x;
	
	if (str.length() > 0)
	{
		for (size_t i = 0; i < str.length(); i++)
		{
			for (size_t r = 0; r < FONT_ROWS; r++)
			{
				uint32_t row = font[str[i]-FONT_BASE][FONT_ROWS - r - 1];
				for (size_t c = 0; c < FONT_COLS; c++)
				{
					if (row & 0x80)
						bmp.pixelr(xbase+c, y+r, border_color);
					row <<= 1;
				}
			}
			xbase += (FONT_COLS + FONT_SPACING);
		}
	}
	
	return xbase;
}







// ========================================
void showhelp()
{
	std::cout << "\nimgs v" << VERSION << '\n';
	std::cout << "Usage:  imgs infile outfile [-options]\n";
	std::cout << "    -?           show this help\n";
	std::cout << "    -f <value>   set fill value\n";
	std::cout << "    -w           warn if images overlap\n";
	std::cout << "    -b           draw border around images";
	std::cout << "    -c <rgb>     change border color";
	std::cout << "    -i           label each image with index";
	std::cout << "    -l           label each image with file title";
}



// ========================================
int main(int argc, char *argv[])
{
	std::vector<ImagePosition> images;

	int32_t coor_type, origin_x, origin_y;
	int32_t min_l=0, max_r=0, min_t=0, max_b=0;
	int32_t l, r, t, b;
	
	uint32_t text_x;
	
	
	uint32_t fill_value = 0xFFFFFF;
	
	bool warn_overlap = false;
	uint8_t *warn_map = 0;
	bool image_overlap;
	
	bool draw_border = false;
	bool draw_index = false;
	bool draw_title = false;
	

	if ( argc < 3 )
	{
		showhelp();
	}
	else
	{
		
		// read options
		for (size_t i = 3; i < argc; i++)
		{
			if (*argv[i] == '-')
			{
				switch (argv[i][1])
				{
					case '?':
						showhelp();
						return 0;
						
					case 'f':
						i++;
						fill_value = atoi(argv[i]);
						break;
						
					case 'w':
						warn_overlap = true;
						break;
					
					case 'b':
						draw_border = true;
						break;
						
					case 'c':
						i++;
						border_color = strtol(argv[i], NULL, 0);
						break;
					
					case 'i':
						draw_index = true;
						break;
					
					case 'l':
						draw_title = true;
						break;
						
					default:
						std::cout << "unknown option: " << argv[i] << '\n';
						return 0;
				}
			}
							
		}

		// read script
		std::string line;
		std::ifstream f(argv[1]);
		ImagePosition ip;
		while ( std::getline(f, line) )
		{
			if ( (line != "") && (line[0] != '#') )
			{
				std::istringstream iss(line);
				 
				iss >> ip.filename >> ip.src_x >> ip.src_y >> ip.src_w >> ip.src_h >> ip.dst_x >> ip.dst_y;
				images.push_back(ip);
				
				l = ip.dst_x;
				r = l + ip.src_w;
				t = ip.dst_y;
				b = t + ip.src_h;
				
				if (l < min_l) min_l = l;
				if (r > max_r) max_r = r;
				if (t < min_t) min_t = t;
				if (b > max_b) max_b = b;
			}
		}
		f.close();
		origin_x = -min_l;
		origin_y = -min_t;
		max_r += origin_x;
		max_b += origin_y;
		std::cout << "script file read" << std::endl;
		
		std::cout << "image count=" << images.size() << std::endl;
		std::cout << "\twidth=" << max_r << "  height=" << max_b << std::endl;
		std::cout << "\torigin.x=" << origin_x << "  origin.y=" << origin_y << std::endl;
		
		// read files and copy to output image
		Bitmap temp(0,0);
		Bitmap bmp(max_b, max_r);
		bmp.fill(fill_value);
		
		warn_map = new uint8_t[max_b * max_r];
		memset(warn_map, 0, max_b * max_r);
		
		for (size_t i = 0; i < images.size(); i++)
		{
			image_overlap = false;
			temp.load(images[i].filename);
			
			// check image/blit bounds
			if ( images[i].src_w > temp.width() )
				std::cout << "WARNING!\t'" << images[i].filename << "' : blit.w [" << images[i].src_w << "] > img.w [" << temp.width() << "]" << std::endl;
			if ( images[i].src_h > temp.height() )
				std::cout << "WARNING!\t'" << images[i].filename << "' : blit.h [" << images[i].src_h << "] > img.h [" << temp.height() << "]" << std::endl;
			
			// add labels if needed
			text_x = 8;
			if (draw_index)
				text_x = print_hex(temp, text_x, 8, i);
			
			if (draw_title)
				print_string(temp, text_x + (FONT_COLS + FONT_SPACING), 8, images[i].filename);
			
			for (int32_t y = 0; y < images[i].src_h; y++)
			{
				int32_t dy = origin_y + images[i].dst_y + y;
				int32_t sy = images[i].src_y + y;
				
				for (int32_t x = 0; x < images[i].src_w; x++)
				{
					int32_t dx = origin_x + images[i].dst_x + x;
					
					if (warn_map[(dy * max_r) + dx])
						image_overlap = true;
						
					warn_map[(dy * max_r) + dx] = true;
					
					if ( draw_border && ( (y==0) || (y==images[i].src_h-1) || (x==0) || (x==images[i].src_w-1) ) )
						bmp.pixelr( dx, dy, border_color );
					else
						bmp.pixelr( dx, dy, temp.pixelr(images[i].src_x + x, sy) );	
				}
			}
			if (warn_overlap && image_overlap)
				std::cout << "WARNING!\t'" << images[i].filename << "' overlapped!" << std::endl;
			
		}
		std::cout << "images merged" << std::endl;
		
		delete warn_map;
		
		// save final image
		bmp.save(argv[2]);
		std::cout << "image saved!!" << std::endl;
	}

	return 0;
}



